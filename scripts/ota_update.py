#!/usr/bin/env python3

from __future__ import annotations

import argparse
import base64
import json
import pathlib
import sys
import urllib.error
import urllib.request
import zlib


def load_default_version() -> str:
    repo_root = pathlib.Path(__file__).resolve().parents[1]
    version_file = repo_root / "VERSION"
    if version_file.exists():
        version_value = version_file.read_text(encoding="utf-8").strip()
        if version_value:
            return version_value
    return "0.0.0-dev"


def parse_args() -> argparse.Namespace:
    default_version = load_default_version()
    parser = argparse.ArgumentParser(
        description="Upload and apply OTA firmware to Blower Pico RP2350"
    )
    parser.add_argument(
        "--host",
        required=True,
        help="Target host or URL (example: 192.168.0.31 or http://192.168.0.31)",
    )
    parser.add_argument(
        "--file",
        required=True,
        help="Firmware binary file (.bin) generated by the build",
    )
    parser.add_argument(
        "--version",
        default=default_version,
        help=f"Version label to send with OTA metadata (default: {default_version})",
    )
    parser.add_argument(
        "--chunk-size",
        type=int,
        default=768,
        help="Raw chunk size in bytes before base64 (default: 768)",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=15.0,
        help="HTTP timeout in seconds (default: 15)",
    )
    parser.add_argument(
        "--no-apply",
        action="store_true",
        help="Only upload the image, do not trigger apply/reboot",
    )
    return parser.parse_args()


def normalize_base_url(host: str) -> str:
    value = host.strip()
    if value.startswith("http://") or value.startswith("https://"):
        return value.rstrip("/")
    return f"http://{value.rstrip('/')}"


def post_json(base_url: str, path: str, payload: dict, timeout: float) -> dict | None:
    request_data = json.dumps(payload, separators=(",", ":")).encode("utf-8")
    request = urllib.request.Request(
        f"{base_url}{path}",
        data=request_data,
        method="POST",
        headers={"Content-Type": "application/json"},
    )
    with urllib.request.urlopen(request, timeout=timeout) as response:
        body = response.read().decode("utf-8", errors="replace").strip()
    if not body:
        return None
    try:
        return json.loads(body)
    except json.JSONDecodeError:
        return None


def get_json(base_url: str, path: str, timeout: float) -> dict | None:
    request = urllib.request.Request(f"{base_url}{path}", method="GET")
    with urllib.request.urlopen(request, timeout=timeout) as response:
        body = response.read().decode("utf-8", errors="replace").strip()
    if not body:
        return None
    try:
        return json.loads(body)
    except json.JSONDecodeError:
        return None


def main() -> int:
    args = parse_args()
    base_url = normalize_base_url(args.host)
    firmware_path = pathlib.Path(args.file).expanduser().resolve()

    if not firmware_path.exists() or not firmware_path.is_file():
        print(f"Error: firmware file not found: {firmware_path}", file=sys.stderr)
        return 1
    if args.chunk_size <= 0:
        print("Error: --chunk-size must be > 0", file=sys.stderr)
        return 1

    firmware_bytes = firmware_path.read_bytes()
    if not firmware_bytes:
        print("Error: firmware file is empty", file=sys.stderr)
        return 1

    firmware_crc32 = zlib.crc32(firmware_bytes) & 0xFFFFFFFF
    total_size = len(firmware_bytes)

    print(f"[1/5] Reading firmware: {firmware_path.name}")
    print(f"      Size: {total_size} bytes")
    print(f"      CRC32: {firmware_crc32}")

    try:
        status = get_json(base_url, "/api/ota/status", args.timeout)
        if status:
            firmware_version = status.get("firmware_version", "unknown")
            print(f"[2/5] Target current version: {firmware_version}")
        else:
            print("[2/5] Target status endpoint returned no JSON")
    except urllib.error.URLError as exc:
        print(f"Error: cannot reach target {base_url}: {exc}", file=sys.stderr)
        return 1

    try:
        print("[3/5] Initializing OTA session")
        begin_response = post_json(
            base_url,
            "/api/ota/begin",
            {
                "size": total_size,
                "crc32": firmware_crc32,
                "version": args.version,
            },
            args.timeout,
        )
        if begin_response and begin_response.get("status") != "ok":
            print(f"Error: OTA begin failed: {begin_response}", file=sys.stderr)
            return 1

        print("[4/5] Uploading chunks")
        offset = 0
        while offset < total_size:
            chunk = firmware_bytes[offset : offset + args.chunk_size]
            payload = {
                "offset": offset,
                "data": base64.b64encode(chunk).decode("ascii"),
            }
            chunk_response = post_json(base_url, "/api/ota/chunk", payload, args.timeout)
            if chunk_response and chunk_response.get("status") != "ok":
                print(
                    f"Error: OTA chunk failed at offset {offset}: {chunk_response}",
                    file=sys.stderr,
                )
                return 1
            offset += len(chunk)
            progress = (offset * 100) // total_size
            print(f"      {progress:3d}% ({offset}/{total_size})", end="\r", flush=True)
        print("")

        finish_response = post_json(base_url, "/api/ota/finish", {}, args.timeout)
        if finish_response and finish_response.get("status") != "ok":
            print(f"Error: OTA finish failed: {finish_response}", file=sys.stderr)
            return 1

        if args.no_apply:
            print("[5/5] Upload complete. Apply skipped (--no-apply).")
            return 0

        print("[5/5] Applying OTA and rebooting target")
        try:
            apply_response = post_json(base_url, "/api/ota/apply", {}, args.timeout)
            if apply_response and apply_response.get("status") not in ("ok", None):
                print(f"Warning: OTA apply response: {apply_response}")
        except urllib.error.URLError:
            # The device can drop connection while rebooting; treat as expected.
            pass

        print("OTA request sent successfully. Device should reboot with new firmware.")
        return 0
    except urllib.error.HTTPError as exc:
        error_body = exc.read().decode("utf-8", errors="replace")
        print(
            f"Error: HTTP {exc.code} on {exc.url}: {error_body}",
            file=sys.stderr,
        )
        return 1
    except urllib.error.URLError as exc:
        print(f"Error: network failure during OTA: {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
